// datasource db {
//   provider     = "mysql"
//   url          = env("DB_URL")
//   relationMode = "prisma"
// }

// generator client {
//   provider             = "prisma-client-py"
//   interface            = "sync"
//   recursive_type_depth = 5
// }

// // Prisma syntax is model <model name> { <field name> <field type> <field type modifiers includes ? and []> <field attributes starts with @> <block-level attributes starts with @@>} 
// // <field type modifiers includes ? and []> -> ? means optional, [] means array, i.e. Posts[] means a user has multiple posts and the posts are stored in an array
// // <field attributes starts with @> -> @id means the field is the primary key, @unique means the field is unique, @default() means the field has a default value, @relation() means the field is a foreign key, @updatedAt means the field is updated automatically when the row is updated, @@index() means the field is indexed
// model User {
//   id                 String          @id @default(cuid()) // The type of default id can be autoincrement() or uuid() or cuid() or autoincrement() or sequence() or custom() or expression(), UUIDS on a sidenote are 128-bit numbers that are completely random and unique across space and time
//   name               String
//   enrolledCourses    Course[]        @relation("EnrolledCourses") // @relation("name") is used to clear up ambiguity when there two exact references to the same table, like ids put into favorite posts and written posts
//   email              String          @unique
//   role               Role            @default(STUDENT) // enum type 
//   // preferences   Json
//   currentInstitution String
//   currentSchool      String
//   writtenPosts       Post[]          @relation("WrittenPosts") // @relation("name") is used to clear up ambiguity when there two exact references to the same table, like ids put into favorite posts and written posts
//   favoritePosts      Post[]          @relation("FavoritePosts")
//   userPreference     UserPreference? @relation(fields: [userPreferenceId], references: [id])
//   userPreferenceId   String?         @unique // must be unique because each user can only have one set of preferences

//   @@unique([name, email])
//   @@index([name, email])
// }

// model Student {

//   currentSession  String
//   currentProgram  String
//   enrolledCourses Course[] @relation("EnrolledCourses")
// }

// model UserPreference {
//   id           String  @id @default(uuid())
//   emailUpdates Boolean @default(true) // Do you want to receive email updates?
//   user         User? // optional relationship, a user can have preferences or not
//   // other preferences
// }

// // 
// // # Pair of Models - Relationship
// // - type of relationship -> description
// // 
// // # Post and User, the relationship between post and user is many to one 
// // - many to one -> a user can have many posts, but a post can only have one user
// // 
// // # Categories and Posts, the relationship between them is many to many
// // - many to many -> a category can have many posts, and a post can have many categories
// // 
// // # User and UserPreferences, the relationship between them is one to one
// // - one to one -> a user has a table of preferences, and each preference has one user it links to
// // 
// model Post {
//   id            String     @id @default(uuid())
//   title         String
//   averageRating Float
//   createdAt     DateTime   @default(now())
//   updatedAt     DateTime   @updatedAt
//   author        User       @relation("WrittenPosts", fields: [authorId], references: [id]) // the field userId is the foreign key, aka what field in the Post table links to the id field in the User table through references: [id]
//   authorId      String
//   favoritedBy   User?      @relation("FavoritePosts", fields: [favoritedById], references: [id])
//   favoritedById String?
//   categories    Category[]
//   // @@id([title, authorId]) we use this when we want to id something of a composite key, i.e. a post identified by its title and author

//   @@index([authorId])
//   @@index([favoritedById])
// }

// // Prisma automatically creates a join table for many to many relationships 
// // In this example, the join table is called PostToCategory that describes the many to many relationship between Post and Category
// model Category {
//   id    String @id @default(uuid())
//   name  String @unique
//   posts Post[]
// }

// model Course {
//   id          String @id @default(uuid())
//   name        String
//   description String
//   students    User[] @relation("EnrolledCourses")
// }

// enum Role {
//   STUDENT
//   LECTURER
//   SUPERUSER
// }
datasource db {
  provider     = "mysql"
  url          = env("DB_URL")
  relationMode = "prisma"
}

generator client {
  provider             = "prisma-client-py"
  interface            = "sync"
  recursive_type_depth = 5
}

// model Student {
//   id                  String   @id @default(cuid())
//   fullName            String N 

//   email               String   @unique
//   password            String
//   contactNo           String
//   currSession         String
//   currInstitution     String
//   currSchool          String
//   currProgram         String
//   currEnrolledCourses String
//   createdAt           DateTime @default(now())
//   updatedAt           DateTime @default(now())
//   posts               Post[]
//   profile             Profile? @relation(fields: [profileId], references: [id])
//   profileId           String?

//   @@unique([fullName, email])
// }

// model Lecturer {
//   id                  String    @id @default(cuid())
//   fullName            String
//   email               String    @unique
//   password            String
//   contactNo           String
//   currTenure          String
//   currInstitution     String
//   currSchool          String
//   currProgram         String
//   currTeachingCourses String
//   createdAt           DateTime? @default(now())
//   updatedAt           DateTime? @updatedAt
// }
// model Post {
//   id         String    @id @default(cuid())
//   created_at DateTime  @default(now())
//   updated_at DateTime  @updatedAt
//   title      String
//   published  Boolean
//   desc       String?
//   comments   Comment[]
// }

// model Comment {
//   id         String   @id @default(cuid())
//   created_at DateTime @default(now())
//   content    String
//   post       Post     @relation(fields: [post_id], references: [id])
//   post_id    String
// }
// model User {
//   id        Int     @id @default(autoincrement())
//   email     String  @unique
//   firstName String?
//   lastName  String?
//   social    String?
//   isAdmin   Boolean @default(false)

//   // Relation fields
//   courses     CourseEnrollment[]
//   testResults TestResult[]       @relation(name: "results")
//   testsGraded TestResult[]       @relation(name: "graded")
//   tokens      Token[]
//   feedback    CourseFeedback[]
// }

// model Token {
//   id         Int       @id @default(autoincrement())
//   createdAt  DateTime  @default(now())
//   updatedAt  DateTime  @updatedAt
//   type       TokenType
//   emailToken String?   @unique // Only used for short lived email tokens
//   valid      Boolean   @default(true)
//   expiration DateTime

//   // Relation fields
//   user   User @relation(fields: [userId], references: [id])
//   userId Int
// }

// model Course {
//   id            Int     @id @default(autoincrement())
//   name          String
//   courseDetails String?

//   // Relation fields
//   members  CourseEnrollment[]
//   tests    Test[]
//   feedback CourseFeedback[]
// }

// model CourseFeedback {
//   id       Int    @id @default(autoincrement())
//   feedback String @db.Text

//   studentId Int
//   courseId  Int
//   student   User   @relation(fields: [studentId], references: [id])
//   course    Course @relation(fields: [courseId], references: [id])
// }

// model CourseEnrollment {
//   createdAt DateTime @default(now())
//   role      UserRole

//   // Relation Fields
//   userId   Int
//   courseId Int
//   user     User   @relation(fields: [userId], references: [id])
//   course   Course @relation(fields: [courseId], references: [id])

//   @@id([userId, courseId])
//   @@index([userId, role])
// }

// model Test {
//   id        Int      @id @default(autoincrement())
//   updatedAt DateTime @updatedAt
//   name      String
//   date      DateTime

//   // Relation Fields
//   courseId    Int
//   course      Course       @relation(fields: [courseId], references: [id])
//   testResults TestResult[]
// }

// model TestResult {
//   id        Int      @id @default(autoincrement())
//   createdAt DateTime @default(now())
//   result    Int // Percentage precise to one decimal point represented as `result * 10^-1`

//   // Relation Fields
//   studentId Int
//   student   User @relation(name: "results", fields: [studentId], references: [id])
//   graderId  Int
//   gradedBy  User @relation(name: "graded", fields: [graderId], references: [id])
//   testId    Int
//   test      Test @relation(fields: [testId], references: [id])
// }

// enum UserRole {
//   STUDENT
//   TEACHER
// }

// enum TokenType {
//   EMAIL // used as a short lived token sent to the user's email
//   API
// }

// future model here
model User {
  id        String    @id @default(cuid())
  fullName  String
  email     String    @unique
  password  String
  isAdmin   Boolean   @default(false)
  contactNo String
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  // Relation Fields
  // profile          Profile? // a user can have a profile or not
  // posts            Post[] // in discussions forum, a user can have many posts
  courses      CourseEnrollment[] // 1 to many relationship, a user can be enrolled in many courses
  feedback     CourseFeedback[] // 1 to many relationship, a user can give feedback to many courses
  posts        Post[] // 1 to many relationship, a user can have many posts
  postComments PostComments[] // 1 to many relationship, a user can have many post comments
  // one user can have only one profile
  userProfile  Profile?
}

model Profile {
  id                  String   @id @default(cuid())
  // role agnostic fields
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  currInstitution     String?
  currSchool          String?
  currProgram         String?
  // role specific fields
  currSession         String?
  currTenure          String?
  currEnrolledCourses String?
  currTeachingCourses String?
  // Relation Fields

  userId String @unique // 1 to 1 relationship, a profile can only belong to one user
  user   User   @relation(fields: [userId], references: [id])
}

model CourseEnrollment {
  createdAt DateTime @default(now()) // when the user is instantiated into the course
  role      UserRole // enum of STUDENT, LECTURER

  // Relation Fields
  userId   String
  courseId String
  // user     User @relation(fields: [userId], references: [id])
  // course   Course @relation(fields: [courseId], references: [id])
  User     User   @relation(fields: [userId], references: [id])

  @@id([userId, courseId])
  @@index([userId, role]) // 
}

model Course {
  id            String  @id @default(cuid())
  name          String
  courseDetails String?
  // Relation Fields
  // members        CourseEnrollment[]
  // feedback        CourseFeedback[]
  post          Post[]
}

model CourseFeedback {
  id     String  @id @default(cuid())
  rating Int
  // comment     String?
  // imageUrl    String?
  // Relation Fields
  // course        Course
  // user          User
  User   User?   @relation(fields: [userId], references: [id])
  userId String?

  @@index([userId])
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation Fields
  courseId     String // the course that this post belongs to
  course       Course         @relation(fields: [courseId], references: [id])
  userId       String // the user that created this post
  user         User           @relation(fields: [userId], references: [id])
  studentId    String?
  PostComments PostComments[]

  @@index([courseId, userId])
  @@index([userId])
}

model PostComments {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  content     String?
  // Relation Fields
  commenterId String
  commenter   User     @relation(fields: [commenterId], references: [id])
  postId      String
  post        Post     @relation(fields: [postId], references: [id])

  @@index([commenterId])
  @@index([postId])
}

enum Role {
  STUDENT
  LECTURER
  SUPERUSER
}

enum UserRole {
  STUDENT
  LECTURER
}

// TODO: Add a model for courses
